##Goal
ts-validator aims to provide runtime validation for value objects.

In other words, given a type definition `T`, provide the implementation for
```typescript
(value: any) => value is T
```

###Example:

Given the type:
```typescript

interface Customer {
    name: string
    email?: string
    isActive: boolean
    lastPurchaseValues: number[]
}
```

We aim to generate something equivalent to:

```typescript

function isCustomer(value: any): value is Customer {
    return (
        (Object(value) === value) && (
            typeof value.name === 'string' && 
            (value.email === undefined || typeof value.email === 'string')
            && typeof value.isActive === 'boolean'
            && (
                (Array.isArray(value.lastPurchaseValues)) && 
                (Array.every( 
                    element => typeof element === 'number', 
                    value.lastPurchaseValues)
                )
            )
        )
    )    
}
```
###What kind of values can we expect to validate with this?

We aim to *validate the intersection of what ts types can denote
and the values that json can express*.

This doesn't mean you can only validate interfaces of primitive values and
arrays of these. You can validate:
    - union / intersection types
    - literal types
    - enums
    - tuples
    

###Why is this useful?

There are many scenarios where a TypeScript function handles values that were generated without type checking. The two main ones are:

- javascript libraries, usually annotated via declaration `.d.ts` files.
- values coming from schemaless serialization, such as the network or a 
database.

For those sources, we have no guards for values not conforming to the types
we expect, and errors generated by that mismatch can be subtle. Also, 
complementing an gradual type definition with runtime checking would help
to catch edge cases and refine those type definitions.

###Why code generation? Couldn't this be done in runtime?

Typescript intentionally drops all type information when emitting
javascript files, so runtime checking doesn't seem plausible. Even if 
reflection was available, we would still think code generation is a good 
way to solve this problem.

### Why JSON and not any other serialization format?

Actually there's not any coupling between these validators and JSON. We just
think that JSON represents a very well understood set of values for developers
worldwide, so we use that meaning to give a clear scope of what can be 
validated.

### Why not use something like json-schema for validations?

Probably you already wrote the type definition for which you need a validator, 
so it makes sense to reuse it and leverage the current tools you're using.
Even if json-schema can express more elaborate value restrictions, we think 
there's little gain on those. Specially because the main benefit of types are the tools that can warn developers about possible mistakes at build/edit time.

Validating that numbers are in a certain range, or that a string is
a valid email, falls outside the scope for this level of validation. This is 
type-conforming validation, so we can fail fast when foreign runtime values 
don't agree with the expected types.


###How should I integrate these generated source files in my repository?

We haven't yet tested this enough to have good recommendations. 
Given that tsc supports specifying multiple paths for module resolution, 
all the generated validators could be put in a folder separate from the
source written by people. 
We expect some users to generate validators just before building, and others
commiting the generated files. Hence we aim to generate idiomatic typescript
and not just a bunch of cryptic expressions.


###Can I use this in production?

This is in **very** early stages. Right now we can only emit javascript expressions
that would evaluate to tue if the value conforms to a type.
- Recursive types are not yet handled.
- There's no emitter with useful or detailed validation errors.

###What can I do, then?
you can run a simple repl script for emitting expressions:
```ts-node src/commands/repl.ts example/example.ts Customer```

This is: `ts-node src/commands/repl.ts <tsFile> <typeName>`

The type in the source file must be exported



##Current Implementation

It's a 3 pass over a typescript type:

1- Use the typecsript compiler to 
[extract the type information](src/typeParser.ts) and build an instance 
of [Type](src/types.ts). 

2- Given a type object, visit it's structre and generate a logical [validation](src/validation.ts) tree.

3- Given a logical validation, [emit](src/expressionEmitter.ts) an expression
that validates the source type.

Also there's a type pretty printer, mostly for figuring out if the type
design made sense.
